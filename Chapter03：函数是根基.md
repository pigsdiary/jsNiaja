#函数是根基

本章我们将讨论：

* 为什么理解函数至关重要
* 函数是如何作为“第一类对象”存在的
* 如何调用函数
* 声明函数
* 函数的参数是如何赋值的
* 一个函数的上下文

***
你可能已经有点惊讶，当打开这本书基础部分的时候，看到要讨论的第一个主题是函数而不是对象。

我们当然会重点讨论对象（第6章），但是归结到实质问题上，像普通人一样编写javascript代码还是像忍者一样编写，最主要的区别是理解javascript是一种函数式语言。
你所编写的javascript代码的优雅程度，取决于你是否认识到这一点。

如果你正在阅读这本书，我们假定你不是新手并且已经有足够的对象基础知识（我们也将在第6章学习更高级的对象概念），但真正理解javascript函数是你可以挥舞的最重要的一个武器。
由于函数如此重要，这一章和下一章将专门用于彻底理解javascript中的函数。

值得注意的是，在javascript中，函数是第一类对象。也就是说，它们可以共存，并且可以像任何其他javascript对象一样进行处理。
就像较为普通的javascript数据类型一样，它们可以通过变量被引用，通过字面量声明，甚至可以作为函数的参数进行传递。

javascript把函数作为一等对象来处理，这从多个层面上来看都很重要，但一个明显的优势就是代码的简洁性。
先来看一段后面会再深入讨论的一段代码，在java中对一个集合进行排序操作：

    Arrays.sort(values,new Comparator<Integer>(){
        public int compare(Integer value1, Integer value2) {
            return value2 - value1;
        }
    });

下面是javascript使用函数式编写的等价代码：

    values.sort(function(value1,value2){ return value2 - value1; });

如果觉得这种写法看起来很奇怪，不用太过担心。当你读完本章，你也将成这种写法的老手，现在我们只是想让你一窥javascript作为函数式语言带来的优点之一。

本章将会深入研究javascript在函数上面的重点功能，给你打下良好的基础，让你的javascript代码可以提升到任何大师都会引以为傲的级别。

##函数的独特之处是什么

你听过多少次有人抱怨说“我讨厌javascript”？

我们愿意打赌肯定有九次十次甚至更多。造成这种现象的直接原因是，有些人试图以另一种他们熟悉的语言的方式来使用javascript。
令人沮丧的是，javascript并不是他们所想象的那样。这种事情发生在那些从其他语言转向javascript的开发者身上最为常见。
其他语言比如java，一种非函数式语言，许多开发者在投身于javascript之前都有学它。

对这些开发者来说，令事情变得更糟糕的是这门语言悲剧的命名：javascript。
暂且不去责骂语言命名背后的那段历史，如果javascript保留它原本的名字LiveScript或者给它起一个不会引起混淆的名字的话，也许开发者对它就不会有那些错误的先入为主的观念。
Because JavaScript has as much to do with Java as a hamburger has to do with ham.

Hamburgers和ham都是食物，肉类制品，就像javascript和java都是受C语言语法影响的编程语言。但除此之外，它们不具有很多共同点，从本质上来说更是不一样。

>造成开发者对javascript不太正确的认知的另一个因素是，大部分开发者都是通过浏览器接触javascript的。
>比起javascript这门语言本身，他们可能更倾向于熟悉从javascript绑定到DOM API。而DOM API……好吧，我们只能说它不会成为“年度最佳API” = =#。但是，这并不是javascript的错。

在我们学习函数在javascript中如何重要之前，我们先思考下，为什么javascript的函数式如此重要，特别是对于那些为浏览器编写的代码而言。

###为什么javascript的函数式如此重要

如果你曾写过浏览器脚本，那你可能已经知道将要讨论的一切。不过我们再过一遍也无妨，确保我们谈论的是同一个东西。

在javascript中，函数和函数式的概念如此重要的一个原因是：函数是最主要的执行模块。除了那些解析到标签就开始运行的行内脚本，我们为页面所写的脚本代码都将包含在一个函数里面。

>回到那段黑暗日子，行内脚本通过document.write()来为页面添加动态的东西。
>而现在，document.write()被认为是落后的，而且也不推荐使用。有更好的途径来让页面变成动态的，比如使用服务器端的模版、客户端的DOM操作，或者是这两者的有效结合。

由于我们的大部分代码都将作为函数调用的结果来运行，你将会看到在编写代码的时候，函数多变和强大的结构赋予了我们很大的灵活性。
我们将用这一章剩余的部分来研究，函数作为“第一类对象”的这个性质，是如何被利用从而让我们大受裨益的。

这是我们第二次使用“第一类对象”这个术语。这是一个重要的概念，因此在我们继续之前，让我们确保我们知道它的真正含义。

####作为第一类对象的函数

javascript中的对象有以下能力和特性：

* 它们可以通过字面量创建
* 它们可以赋值给变量、数组的项，和其他对象的属性
* 它们可以作为参数传递给函数
* 它们可以作为函数的返回值
* 它们可以拥有动态创建并赋值的属性

javascript中的函数也具有以上所有能力和特性，可以像其他对象一样对其进行处理。因此我们说，它们是第一类对象。

除了可以像其他对象一样进行处理，函数还拥有一个特殊的能力，那就是它们可以被调用。

函数调用经常是以异步的形式进行的，我们来讨论一下这是为什么。

####浏览器事件循环

如果你有过GUI桌面程序的编程经历，你就会知道，大部分都是采用以下类似的方式：

1. 设置用户界面
2. 进入一个循环，等待事件的发生
3. 为事件调作监听器

浏览器编程与它并没什么区别。不同之处在于，我们的代码并不负责事件循环的运行和事件的调度，处理这些事情的是浏览器。

我们负责为那些可能出现在浏览器里的事件设置监听器。这些事件处于一个事件队列（一个先进先出的队列，后面会进一步讨论）中，浏览器通过调用我们为事件创建的监听器来调度这些事件。

由于事件发生的时间和顺序都不可预测，因此我们说，处理函数（监听器）的调用是异步的。

以下这些类型的事件有可能发生，包括：

* 浏览器事件，比如当一个页面完成加载时，或者当它卸载时
* 网络事件，比如响应Ajax请求
* 用户事件，比如鼠标的点击、移动，或者按键
* 定时器事件，比如timeout设置的时间间隔到了

我们的大部分代码都是执行这些事件的结果。考虑以下代码：

    function startup(){
        //do something wonderful
    }
    window.onload = startup;

我们创建了一个函数作为load事件的监听器。创建的函数作为行内脚本的一部分（假定它出现在最顶层，并且不被包含在任何函数里面），但在浏览器完成页面的加载并触发load事件之前，
我们在函数里面所做的有趣的事情是不会发生的。

事实上，如果我们喜欢，我们可以把它简化到一行代码。看：

    window.onload = function() { // do something wonderful };

如果这种创建函数的手法让你感到迷惑，放心，我们保证在3.2节会让你彻底理解的。

>####不唐突的javascript
>将一个函数赋值给window实例的onload属性可能并不是你设置监听器的习惯用法，也许你更倾向于使用&lt;body&gt;标签的onload属性。
>
>不管使用哪种方法都可以达到我们想要的效果。不过使用window.onload比较受javascript忍者们的欢迎，因为它遵循了一个流行的原则：不唐突的javascript。
>
>还记得CSS的诞生开创了将样式表从文档标记中分离出来吗？很少人会认为，将样式从结构中分离出去是个糟糕的举动。不唐突的javascript做着同样的事情，它将行为（behavior）
>从文档标记中分离出去。
>
>如此一来，页面中便有三个主要的组件：结构、样式和行为，各自分开来。结构定义在文档标记中，样式位于&lt;style&gt;标签里或外部样式表中，
>而行为则处于&lt;script&gt;标签里或外部脚本文件中。
>
>在本书中你将不会看到嵌入到文档标记中的任何脚本代码，除非这样做可以清晰地表达某个观点或者可以极大地简化例子。

浏览器的事件循环是单线程的，意识到这一点很重要。事件队列中的每一个事件，将按照它们在队列中的顺序被处理。这就是所谓的FIFO列表。
每个事件都在各自的时间顺序(turn)里被处理，而且其他事件必须等到当前事件的时间顺序结束。任何情况下都不会出现单线程同时处理两个事件。

想象一下在银行里面，每一个人都排在各自的队列中等待自己被出纳员们“处理”。但在javascript中，只有一个出纳窗口打开着，所以每次只能“处理”一个客户。

这个概念是页面中javascript的核心，也是我们将在本书的例子中反复看到的：代码预先写好，以后在将来的时间里执行。
除了内嵌的代码，我们放到页面里的大部分代码都将作为一个事件的结果来执行。

重要的是要意识到，浏览器将事件放进队列的机制是处于事件循环模型之外的。该机制需要确定事件何时发生并将其推进事件队列中，它并不参与处理这些事件的线程。

例如，当一个用户在页面上滑动鼠标的时候，浏览器将发现这些动作并将mousemove这个事件推到事件队列中。事件循环最终将会处理这些事件并触发任何为这些事件创建的监听器。

这样的事件监听器，是一个被称为“回调函数”的概念的例子。让我们来探讨这个非常重要的概念。

####回调概念

每当我们设置了一个在将来会被调用的函数，无论是通过浏览器还是其他代码，我们便是设置了一个“回调”。
这个词源于这样的一个事实：我们创建了一个当其他代码执行到适当的时候会“回调”的一个函数。

回调是高效使用javascript的一个重要组成部分，我们将会看到如何使用回调的真实例子，不过这有点复杂，所以在那之前，我们先剖析下回调的概念，研究它最简单的形式。

我们将在这本书的其他地方看到回调被广泛作为事件监听器，但这仅仅是回调的一种形式。我们甚至可以在我们代码中利用自己的回调。
这里有一个例子，下面这个没有实际作用的函数接收一个函数引用作为参数，并将该参数作为回调来调用它：

    function useless(callback) { return callback(); }

正如上面这个函数，它展示了将一个函数作为参数传递给另一个函数，并随后调用那个函数的能力。

我们可以这样来测试这个函数：

    var text = 'Domo arigato!';
    assert(
        useless(function(){ return text; }) === text,
        "The useless function works! " + text
    );

在这里，我们使用了上一章提及的assert()测试函数证实了这个回调函数被调用了并返回了期望值。

这实在、实在是太方便了。这是因为javascript的函数式特性让我们可以将函数作为第一类对象来处理。

现在让我们看一个不那么没用的例子，并将它和在非函数式语言中使用回调进行对比。

###根据一个比较来排序

大部分情况下，当我们拥有一个数据集合的时候，都需要以某种方式对其进行排列。事实证明，我们需要一个回调函数，它可以做任何、但也是最简单的排序操作。

比方说，我们有一个随机排序的数字数组：213，16，2058，54，10，1965，57，9。也许那个顺序刚刚好。但迟早我们都会对其进行重新排序，以符合某种排序规则。

java和javascript都提供了一个简单的方法来对数组进行升序排序。

这是java的实现方式：

    Integer[] values = { 213, 16, 2058, 54, 10, 1965, 57, 9 };
    Arrays.sort(values);

而这是javascript版本的：

    var values = [ 213, 16, 2058, 54, 10, 1965, 57, 9 ];
    values.sort();

>我们并不是在给java挑刺，真的不是。它是一门好语言。我们在这里拿java举例子仅仅是因为它是非函数式语言的一个很好的例子，
>而且大部分投向javascript的开发者也很熟悉它。

这两种语言对于排序的实现有一些不同。尤其是，java提供了一个包含静态函数的类，而javascript则在数组本身提供了一个方法。
这两种手段都是简单且容易理解的。不过，当我们决定要以升序以外的其他方式，比如降序来进行排列的时候，事情开始出现明显的分歧。

为了允许我们以任意想要的顺序进行排序，这两种语言都可以让我们提供一个比较算法，从而告诉排序算法这些值应该如何排序。
与其让排序算法决定如何排序，我们可以提供一个函数来进行比较。这个函数作为回调，排序算法将在需要的时候调用它。
这个概念在两种语言里有点相似，不过实现的方法却是大相径庭。

在非函数式的java里，方法不能存在于自身，也不能作为参数传递给其他方法。相反，方法必须作为一个对象的成员来声明，这个对象可以被实例化，也可以被传递给一个方法。
因此，Arrays.sort()方法接收一个包含了比较方法的对象，该方法在需要的时候将被作为回调函数来调用。同时，这个对象和方法必须符合已知的类型（java是强类型的），
因此需要定义一个接口。在这个例子中，java库提供了下面这个接口（通常情况下，你可能需要定义你自己的接口）：

    public interface Comparator<T> {
        int compare(T t, T t1);
        boolean equals(Object o);
    }

一个java新手可能会创建一个具体类来实现这个接口。不过为了公平比较，我们假设他使用了内嵌的匿名实现。使用Arrays.sort()这个静态方法来进行降序排序的话，代码看起来像这样：

    Arrays.sort(values,new Comparator<Integer>(){
        public int compare(Integer value1, Integer value2) {
            return value2 - value1;
        }
    });

Comparator中的compare()方法接收两个参数，如果这两个参数需要反过来排序的话，这个方法将返回一个负值，否则返回一个正值，如果这两个值相等则返回0。
根据简单的减法的返回值，便可以对数组进行降序排序。

上面的代码的运行结果如下：

    2058, 1965, 213, 57, 54, 16, 10, 9

这并不是很复杂，但它确实用到不少语法，特别是当你需要引入所依赖的接口声明来做一些实际上很简单的事情的时候。

当我们考虑用javascript通过它的函数式特性来实现等价代码的时候，更能明显地看出上面的方法显得很笨重：

    var values = [ 213, 16, 2058, 54, 10, 1965, 57, 9 ];
    values.sort(function(value1,value2){ return value2 - value1; });

没有接口，没有额外的对象，仅仅一行代码。我们简单地声明了一个直接传递给sort()方法的匿名函数。

javascript允许我们创建一个函数作为单独的实体，并可以将它作为参数传递给另一个函数，通过参数来引用它，所有的这一切跟其他对象类型没什么两样。
“第一类对象”这个名号的威力开始显现。

可能在不久的将来，这种特性也将出现在非函数式语言中，比如java。

javascript最重要的特性之一就是，在表达式可以出现的任何位置我们都可以创建函数。除了可以使代码更健壮且易于理解（通过将函数声明靠近使用该函数的地方），
这个特性也可以排除污染全局命名空间的可能（如果一个函数不会被多次引用的话，那就不用给它一个不必要的名字）。

无论函数是如何声明的，它们都可以被当作值来引用，在可复用的代码库中也可以作为基本的构建块。
理解函数（包括匿名函数）在最基本的层面上是如何运作的，将会明显提升我们编写清晰、简洁和可复用的代码的能力。

现在让我们更进一步看看函数是如何声明和被调用的。从表面上来看，声明和调用函数似乎没什么，实际上有很多事情是我们需要注意的。

##函数声明

如同用数字字面量创建一个数字，javascript的函数通过函数字面量来创建。记住一点，作为第一类对象，函数值可以像其他值类型如字符串、数字一样来使用。
而且无论你是否意识到这一点，你一直以来都是这么做的。

函数字面量由四部分组成：

1. function关键字
2. 一个可选的名字，如果指定它，则必须是一个合法的javascript标识符
3. 一个由逗号隔开的参数列表，包含在圆括号里面。参数名必须是合法的标识符，参数列表可以为空。圆括始终是必需的，即使它的参数列表为空。
4. 函数体，即包含在花括号里面的若干javascript语句。函数体可以为空，但是花括号必须始终存在。

函数名是可选的，这可能会让一些开发者感到意外，但我们在前面的章节中已经见过匿名函数的例子了。如果一个函数无须通过它的名字来引用它，那么我们不用非得给它一个名字。
（正如一个关于猫的玩笑话：当你叫一只猫而又它不会过来的时候，为什么要给猫起名字呢？）

当一个函数是命名的时候，这个名字在声明该函数的整个作用域内都是可以被访问的。
此外，如果一个命名函数是在顶级（即不在任何函数体内）声明的，在window实例上将会使用这个函数名创建一个指向该函数的属性。

最后，所有的函数都有一个name属性，该属性用字符串类型保存着函数的名字。匿名函数也依旧拥有这个属性，其值为空字符串。

我们可以写一些测试例子证明以上所说的。如下：

    <script type="text/javascript">
    //定义一个命名函数。该名字在当前的整个作用域内都是可被访问的，同时也被隐性地添加为window的一个属性。
    function isNimble(){ return true; }
    //第一个测试，证明了在window上确实利用函数创建了一个属性，指向该函数。
    assert(
        typeof window.isNimble === "function",
        "isNimble() defined");
    //第二个测试，证明了函数的name属性确实保存着它的名字。
    assert(
        isNimble.name === "isNimble",
        "isNimble() has a name");

    //定义一个匿名函数，并赋值给一个变量：canFly。这个变量是window的一个属性，而且函数的name属性为空。
    var canFly = function(){ return true; };
    //证明canFly这个变量引用着这个匿名函数，它的name属性是空字符串而不是null。
    assert(
        typeof window.canFly === "function",
        "canFly() defined");
    assert(
        canFly.name === "",
        "canFly() has no name");

    //创建一个匿名函数，通过window的一个属性来引用。
    window.isDeadly = function(){ return true; };
    //证明该属性确实引用着这个函数。
    assert(
        typeof window.isDeadly === "function",
        "isDeadly() defined");

    //在outer函数里面定义了一个inner函数。
    function outer(){
        //证明了在inner函数声明之前或之后，都可以引用它。并且它并不存在于全局作用域上。
        assert(typeof inner === "function",
        "inner()inscopebeforedeclaration");

        function inner(){}
        assert(
            typeof inner === "function",
            "inner() in scope after declaration");
        assert(
            window.inner === undefined,
            "inner() not in global scope");
    }

    outer();
    //证明了outer函数可以在全局作用域访问，而inner函数则不能。
    assert(
        window.inner === undefined,
        "inner() still not in global scope");

    //将一个命名函数赋值给一个变量，该变量名并不会对函数的name属性造成影响。name属性由定义函数的字面量决定。
    window.wieldsSword = function swingsSword() { return true; };
    assert(
        window.wieldsSword.name === 'swingsSword',
        "wieldSword's real name is swingsSword");
    </script>

在这个测试例子中，我们通过三种不同的方式声明了全局作用域内的函数：

* isNimble()函数以命名函数的方式声明。这是大部分开发者见过的最普遍的方式。当你看完这本书，你就不会这样写了。
* 创建了一个匿名函数并赋值给一个全局变量canFly。由于javascript的函数性特性，函数可以通过它的引用来调用：canFly()。在这方面，这与声明一个名为"canFly"的命名函数一样，
但并不完全相同。最主要的区别是函数的name属性是""，而不是"canFly"。
* 声明了另一个匿名函数并赋值给一个名为isDeadly的window属性。同样的，我们可以通过这个属性来调用函数（window.isDeadly()或者更直接点isDeadly()），
在功能上，这与一个名为"isDeadly"的命名函数一样。

在整个例子中，我们通过断言证明了以下这些：

* window.isNimble被定义为一个函数。这证明了命名的函数被添加成为window的属性。
* 命名函数isNimble拥有一个name属性，值为字符串"isNimble"。
* window.canFly被定义为一个函数，证明了全局变量，甚至那些包含了其他的函数，最终都存在于window上。
* 赋值给canFly的匿名函数拥有一个name属性，值为空字符串。
* window.isDeadly被定义为一个函数。

接着便到了测试局部函数的时间了。我们创建了一个函数，并恰当地命名为outer，以便测试在非全局作用域内声明的函数。
我们声明了一个内部函数名为inner。但在它声明之前，我们测试到它是存在于作用域内的。这证明了，一个函数在声明它的整个作用域内都是可访问的，可以提前引用。

接着我们声明了函数，检查了它outer函数的作用域内，但不在全局作用域内。

最后，我们执行了内部测试并再次断言，inner函数并不在全局作用域内。

这些概念非常重要,因为它们放下了功能性代码提供的命名、流程和结构基础，并通过我们采用的函数式编程，建立了对我们大有裨益的框架。

我们创建inner函数的目的，是说明在outer函数里，可以提前引用inner函数。
你或许会好奇：当我们声明一个函数的时候，这个函数在哪个作用域内是可被访问的呢？
这是个好问题，下面我们将会回答这个问题。

###作用域和函数

当我们声明一个函数的时候，我们不仅仅需要关心这个函数在哪个作用域内可被访问，同时也要关心函数本身创建的作用域以及这些作用域是如何影响函数内部的声明的。

javascript里的作用域表现得与其他大部分那些受C语法影响的语言有些不同，大部分那些语言使用了花括号作为块级分隔，每一块便创建一个作用域。而javascript并不是这样。

在javascript中，作用域通过函数来声明，而不是块。在一个块里创建的声明的作用域，在这个块结束的时候并不会终止。

考虑下这些代码：

    if (window) {
        var x = 213;
    }
    alert(x);

在大部分其他语言里，期望是，x的作用域在if创建的块结束时便终止了，alert时的x为undefined。
但当我们在页面上运行这些代码的时候，213将被alert出来，因为javascript在块结束的时候，并不会终止作用域。

这看起来貌似挺简单的。但作用域规则还是有一些细微区别的，这取决于声明的是什么。有些区别可能会让你惊讶：

* 声明变量的作用域，从声明的地方开始，到声明它的函数的结尾。忽略代码块的嵌套。
* 命名函数的作用域，存在于声明它的整个函数里。忽略代码块的嵌套。（有些称之为hoisting）
* 出于声明作用域的目的，全局上下文表现得就像一个包含着页面上所有代码的大函数。

让我们证明一下，看看这个代码片段：

    function outer(){
        var a = 1;
        function inner(){ // does nothing  }
        var b = 2;
        if (a == 1) {
            var c = 3;
        }
    }
    outer();

在这段代码里，我们声明了五个变量：一个名为outer的外部函数，一个位于outer内部的名为inner的函数，还有三个位于外部函数里面的数字变量名为a,b,c。

为了测试这些变量在哪里位于作用域内，在哪里处于作用域外，我们将在例子中散布一个测试的代码块，测试每一个声明的变量。
每个测试都断言那个变量处于作用域内（除了第一个断言，它并不是用来测试的，它只是用来帮助代码更易于阅读）

以下是测试的代码块：

    assert(true,"some descriptive text");
    assert(typeof outer==='function',
      "outer() is in scope");
    assert(typeof inner==='function',
      "inner() is in scope");
    assert(typeof a==='number',
      "a is in scope");
    assert(typeof b==='number',
      "b is in scope");
    assert(typeof c==='number',
      "c is in scope");

要注意在大多数情况下，有些断言将会失败。在正常情况下，我们都期望我们的断言总是成功的。
但在这段仅仅用来示范的代码里，这符合我们的目的：断言的成功与失败，和被测试的变量是否处于作用域内相符。

下面便是完整的测试例子，删掉了重复的测试代码块以便易于理解（无论在哪里删掉测试代码块，我们都用// test code here 作出提示，让你清楚测试代码块位于这里。）

    <script type="text/javascript">
    assert(true,"|----- BEFORE OUTER -----|");
    // test code here（在我们定义任何东西之前运行代码块。我们的测试断言每个变量都处于作用域内，所以除了那些可以提前引用的变量的测试之外，其他的都会失败。
    因此，在这个位置，只有顶级的outer函数处于作用域内。）

    function outer(){
        assert(true,"|----- INSIDE OUTER, BEFORE a -----|");
        // test code here（在outer函数之内，但在任何其他东西声明之前运行代码块。outer函数依旧处于作用域内，还有定义在它里面的inner函数也是。
        函数可以提前引用，但变量声明则不行，所以其他的断言都失败了。）
        var a = 1;
        assert(true,"|----- INSIDE OUTER, AFTER a -----|");
        // test code here（在outer函数之内、变量a声明之后运行代码块，结果显示a也被添加进作用域内。）
        function inner(){ // does nothing }
        var b = 2;
        assert(true,"|----- INSIDE OUTER, AFTER inner() AND b -----|");
        // test code here（在inner函数声明、变量b声明之后运行代码块，结果显示b也被添加进作用域内。）
        if (a == 1) {
            var c = 3;
            assert(true,"|----- INSIDE OUTER, INSIDE if -----|");
            // test code here（在if代码块内、变量c声明之后运行代码块，结果显示所有变量都在作用域内。）
        }
        assert(true,"|----- INSIDE OUTER, OUTSIDE if -----|");
        // test code here（在outer函数之后、if代码块结束之后运行代码块，结果显示所有变量都在作用域内，虽然声明c的if代码块结束了。）
    }
    outer();
    assert(true,"|----- AFTER OUTER -----|");
    // test code here（在全局作用域、outer函数声明之后运行代码块，记住，只有outer存在于作用域内。因为outer里面定义的任何东西在outer外面是无法访问的。）
    </script>

和预期的一样，断言有很多失败，因为每一个我们放置测试代码块的地方并不是所有变量都在作用域内。

值得注意的是，inner的声明在整个outer函数里面都是有效的，而变量a, b, c仅仅存在于它们声明的地方到函数的结束。
这清楚地表明，函数在它们所处的作用域内可能提前引用，而变量则不行。

同样值得注意的有，if代码块的结束并不会终止c的作用域。变量c尽管被嵌套在一个块里面，但从它的声明的地方开始，到outer函数结束它都是有定义的，就像那些不在嵌套块中定义的变量一样。

>现在你能稍微理解作用域了，应该能够回答这面这个问题了：
>与其每次都要剪切、粘贴测试代码块，为什么不创建一个函数把代码块包含进来，然后在需要的时候调用它？
>（这是因为，创建一个函数的同时会创建一个新的作用域，不利于测试。）

现在我们已经看到函数是如何声明的了，接下来让我们看下该如何调用它们。

##函数调用

我们都调用过javascript函数，但你有没有停下来想过，当一个函数被调用的时候真正发生了什么？这一部分，我们将研究下函数调用的几种方法。

事实证明，调用函数的方法对函数代码的执行有很大的影响，特别是this参数的创建。其中的区别比第一次看起来要重要得多。
我们将在本节研究它，并在本书的其他部分利用它帮助我们将代码提升到忍者级别。

实际上有四种不同的方法调用一个函数，每种都有它的独特之处：

* 作为一个函数，函数通过一种比较简单的方式来调用。
* 作为一个方法，将调用与一个对象联系起来，可以如面向对象那样编程。
* 作为一个构造函数，一个新的对象将被创建。
* 通过函数的apply()或call()方法，这比较复杂，后面将会深入讨论。

除最后一个之外，对于以上这些方法，函数调用都是一对圆括号跟着一个计算结果为函数引用的表达式。任何要传递给函数的参数，都包括在圆括号里并用逗号隔开。

比如：

    expression(arg1, arg2);

在我们深入讨论那四种函数调用的方法之前，让我们来看看在调用时传递参数的时候发生了什么。

###从形参到函数实参
